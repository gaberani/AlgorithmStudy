import sys, copy
def dfs(m, cnt, sum, cand, flag): # 인접 경로 찾아서 이동하는 것과 비슷한 알고리즘
    global nums, visit, max_sum
    if cnt == 10 or flag == 4: # flag는 윷놀이 판을 모두 돈 돌의 수
        max_sum = max(max_sum, sum)
    else:
        for i in range(len(cand)):
            x, y = cand[i] # cand는 윷놀이 판에 올려져 있는 돌의 위치
            if not(arr[x][y][nums[cnt]-1]):
                temp = cand[i][:]
                cand.pop(i)
                visit[x][y] = 0
                dfs(m-1, cnt+1, sum, copy.deepcopy(cand), flag+1)
                visit[x][y] = 1
                if len(cand):
                    cand.insert(i, temp[:])
                else:
                    cand.append(temp[:])
            elif arr[x][y][nums[cnt]-1]:
                nx, ny = arr[x][y][nums[cnt]-1]
                if not(visit[nx][ny]):
                    cand[i], visit[x][y], visit[nx][ny] = (nx, ny), 0, 1
                    dfs(m, cnt+1, sum+nx, copy.deepcopy(cand), flag)
                    cand[i], visit[x][y], visit[nx][ny] = (x, y), 1, 0
        if m < 4-flag:
            if not(visit[arr[0][nums[cnt]-1][0]][arr[0][nums[cnt]-1][1]]):
                cand.append(arr[0][nums[cnt]-1]); visit[arr[0][nums[cnt]-1][0]][arr[0][nums[cnt]-1][1]] = 1
                dfs(m+1, cnt+1, sum+arr[0][nums[cnt]-1][0], copy.deepcopy(cand), flag)
                cand.pop(); visit[arr[0][nums[cnt]-1][0]][arr[0][nums[cnt]-1][1]] = 0

arr = [ # 윷놀이 판을 담는 배열 생성, 겹치는 번호는 2차 배열로 저장
    [(2, 0), (4, 0), (6, 0), (8, 0), (10, 0)],
    0, [[(4, 0), (6, 0), (8, 0), (10, 0), (12, 0)]],
    0, [[(6, 0), (8, 0), (10, 0), (12, 0), (14, 0)]],
    0, [[(8, 0), (10, 0), (12, 0), (14, 0), (16, 1)]],
    0, [[(10, 0), (12, 0), (14, 0), (16, 1), (18, 0)]],
    0, [[(13, 0), (16, 0), (19, 0), (25, 0), (30, 0)]],
    0, [[(14, 0), (16, 1), (18, 0), (20, 0), (22, 1)]],
    [[(16, 0), (19, 0), (25, 0), (30, 0), (35, 0)]], [[(16, 1), (18, 0), (20, 0), (22, 1), (24, 1)]],
    0, [[(19, 0), (25, 0), (30, 0), (35, 0), (40, 0)], [(18, 0), (20, 0), (22, 1), (24, 1), (26, 1)]],
    0, [[(20, 0), (22, 1), (24, 1), (26, 1), (28, 1)]],
    [[(25, 0), (30, 0), (35, 0), (40, 0), 0]], [[(22, 0), (24, 0), (25, 0), (30, 0), (35, 0)]],
    0, [[(24, 0), (25, 0), (30, 0), (35, 0), (40, 0)], [(24, 1), (26, 1), (28, 1), (30, 1), (32, 0)]],
    0, [[(25, 0), (30, 0), (35, 0), (40, 0), 0], [(26, 1), (28, 1), (30, 1), (32, 0), (34, 0)]],
    [[(30, 0), (35, 0), (40, 0), 0, 0]], [[(25, 0), (30, 0), (35, 0), (40, 0), 0], [(28, 1), (30, 1), (32, 0), (34, 0), (36, 0)]],
    [[(26, 0), (25, 0), (30, 0), (35, 0), (40, 0)]], [[(27, 0), (26, 0), (25, 0), (30, 0), (35, 0)], [(30, 1), (32, 0), (34, 0), (36, 0), (38, 0)]],
    0, [[(35, 0), (40, 0), 0, 0, 0], [(28, 0), (27, 0), (26, 0), (25, 0), (30, 0)]],
    0, [[(34, 0), (36, 0), (38, 0), (40, 0), 0]],
    0, [[(36, 0), (38, 0), (40, 0), 0, 0]],
    [[(40, 0), 0, 0, 0, 0]], [[(38, 0), (40, 0), 0, 0, 0]],
    0, [[(40, 0), 0, 0, 0, 0]],
    0, [[0, 0, 0, 0, 0]]
]
nums = list(map(int, sys.stdin.readline().split()))
max_sum, visit = 0, [[0]*2 for _ in range(41)]
dfs(1, 1, arr[0][nums[0]-1][0], [arr[0][nums[0]-1][:]], 0)
print(max_sum)